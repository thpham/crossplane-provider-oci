/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type KerberosObservation struct {
}

type KerberosParameters struct {

	// (Updatable) Version of the keytab Secret in the Vault to use as a backup.
	// +kubebuilder:validation:Optional
	BackupKeyTabSecretVersion *float64 `json:"backupKeyTabSecretVersion,omitempty" tf:"backup_key_tab_secret_version,omitempty"`

	// (Updatable) Version of the keytab Secret in the Vault to use.
	// +kubebuilder:validation:Optional
	CurrentKeyTabSecretVersion *float64 `json:"currentKeyTabSecretVersion,omitempty" tf:"current_key_tab_secret_version,omitempty"`

	// (Updatable) Specifies whether to enable or disable Kerberos.
	// +kubebuilder:validation:Optional
	IsKerberosEnabled *bool `json:"isKerberosEnabled,omitempty" tf:"is_kerberos_enabled,omitempty"`

	// (Updatable) The Kerberos realm that the mount target will join.
	// +kubebuilder:validation:Required
	KerberosRealm *string `json:"kerberosRealm" tf:"kerberos_realm,omitempty"`

	// (Updatable) The OCID of the keytab Secret in the Vault.
	// +kubebuilder:validation:Optional
	KeyTabSecretID *string `json:"keyTabSecretId,omitempty" tf:"key_tab_secret_id,omitempty"`
}

type LdapIdmapObservation struct {
}

type LdapIdmapParameters struct {

	// (Updatable) The maximum amount of time the mount target is allowed to use a cached entry.
	// +kubebuilder:validation:Optional
	CacheLifetimeSeconds *float64 `json:"cacheLifetimeSeconds,omitempty" tf:"cache_lifetime_seconds,omitempty"`

	// (Updatable) The amount of time that the mount target should allow an entry to persist in its cache before attempting to refresh the entry.
	// +kubebuilder:validation:Optional
	CacheRefreshIntervalSeconds *float64 `json:"cacheRefreshIntervalSeconds,omitempty" tf:"cache_refresh_interval_seconds,omitempty"`

	// (Updatable) All LDAP searches are recursive starting at this group.  Example: CN=Group,DC=domain,DC=com
	// +kubebuilder:validation:Optional
	GroupSearchBase *string `json:"groupSearchBase,omitempty" tf:"group_search_base,omitempty"`

	// (Updatable) The amount of time that a mount target will maintain information that a user is not found in the ID mapping configuration.
	// +kubebuilder:validation:Optional
	NegativeCacheLifetimeSeconds *float64 `json:"negativeCacheLifetimeSeconds,omitempty" tf:"negative_cache_lifetime_seconds,omitempty"`

	// (Updatable) The OCID of the first connector to use to communicate with the LDAP server.
	// +kubebuilder:validation:Optional
	OutboundConnector1Id *string `json:"outboundConnector1Id,omitempty" tf:"outbound_connector1id,omitempty"`

	// (Updatable) The OCID of the second connector to use to communicate with the LDAP server.
	// +kubebuilder:validation:Optional
	OutboundConnector2Id *string `json:"outboundConnector2Id,omitempty" tf:"outbound_connector2id,omitempty"`

	// (Updatable) Schema type of the LDAP account.
	// +kubebuilder:validation:Optional
	SchemaType *string `json:"schemaType,omitempty" tf:"schema_type,omitempty"`

	// (Updatable) All LDAP searches are recursive starting at this user.  Example: CN=User,DC=domain,DC=com
	// +kubebuilder:validation:Optional
	UserSearchBase *string `json:"userSearchBase,omitempty" tf:"user_search_base,omitempty"`
}

type StorageMountTargetObservation struct {

	// The OCID of the associated export set. Controls what file systems will be exported through Network File System (NFS) protocol on this mount target.
	ExportSetID *string `json:"exportSetId,omitempty" tf:"export_set_id,omitempty"`

	// The OCID of the mount target.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Additional information about the current 'lifecycleState'.
	LifecycleDetails *string `json:"lifecycleDetails,omitempty" tf:"lifecycle_details,omitempty"`

	// The OCIDs of the private IP addresses associated with this mount target.
	PrivateIPIds []*string `json:"privateIpIds,omitempty" tf:"private_ip_ids,omitempty"`

	// The current state of the mount target.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// The date and time the mount target was created, expressed in RFC 3339 timestamp format.  Example: 2016-08-25T21:10:29.600Z
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`
}

type StorageMountTargetParameters struct {

	// The availability domain in which to create the mount target.  Example: Uocm:PHX-AD-1
	// +kubebuilder:validation:Required
	AvailabilityDomain *string `json:"availabilityDomain" tf:"availability_domain,omitempty"`

	// (Updatable) The OCID of the compartment in which to create the mount target.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/identity/v1alpha1.Compartment
	// +kubebuilder:validation:Optional
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// Reference to a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDRef *v1.Reference `json:"compartmentIdRef,omitempty" tf:"-"`

	// Selector for a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDSelector *v1.Selector `json:"compartmentIdSelector,omitempty" tf:"-"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: {"Operations.CostCenter": "42"}
	// +kubebuilder:validation:Optional
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) A user-friendly name. It does not have to be unique, and it is changeable. Avoid entering confidential information.  Example: My mount target
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see Resource Tags. Example: {"Department": "Finance"}
	// +kubebuilder:validation:Optional
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The hostname for the mount target's IP address, used for DNS resolution. The value is the hostname portion of the private IP address's fully qualified domain name (FQDN). For example, files-1 in the FQDN files-1.subnet123.vcn1.oraclevcn.com. Must be unique across all VNICs in the subnet and comply with RFC 952 and RFC 1123.
	// +kubebuilder:validation:Optional
	HostnameLabel *string `json:"hostnameLabel,omitempty" tf:"hostname_label,omitempty"`

	// A private IP address of your choice. Must be an available IP address within the subnet's CIDR. If you don't specify a value, Oracle automatically assigns a private IP address from the subnet.
	// +kubebuilder:validation:Optional
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// (Updatable) The method used to map a Unix UID to secondary groups, if any.
	// +kubebuilder:validation:Optional
	IdmapType *string `json:"idmapType,omitempty" tf:"idmap_type,omitempty"`

	// (Updatable) Kerberos details needed to create configuration.
	// +kubebuilder:validation:Optional
	Kerberos []KerberosParameters `json:"kerberos,omitempty" tf:"kerberos,omitempty"`

	// (Updatable) Mount target details about the LDAP ID mapping configuration.
	// +kubebuilder:validation:Optional
	LdapIdmap []LdapIdmapParameters `json:"ldapIdmap,omitempty" tf:"ldap_idmap,omitempty"`

	// (Updatable) A list of Network Security Group OCIDs associated with this mount target. A maximum of 5 is allowed. Setting this to an empty array after the list is created removes the mount target from all NSGs. For more information about NSGs, see Security Rules.
	// +kubebuilder:validation:Optional
	NsgIds []*string `json:"nsgIds,omitempty" tf:"nsg_ids,omitempty"`

	// The OCID of the subnet in which to create the mount target.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/core/v1alpha1.Subnet
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// Reference to a Subnet in core to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDRef *v1.Reference `json:"subnetIdRef,omitempty" tf:"-"`

	// Selector for a Subnet in core to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDSelector *v1.Selector `json:"subnetIdSelector,omitempty" tf:"-"`
}

// StorageMountTargetSpec defines the desired state of StorageMountTarget
type StorageMountTargetSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     StorageMountTargetParameters `json:"forProvider"`
}

// StorageMountTargetStatus defines the observed state of StorageMountTarget.
type StorageMountTargetStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        StorageMountTargetObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// StorageMountTarget is the Schema for the StorageMountTargets API. Provides the Mount Target resource in Oracle Cloud Infrastructure File Storage service
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type StorageMountTarget struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              StorageMountTargetSpec   `json:"spec"`
	Status            StorageMountTargetStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// StorageMountTargetList contains a list of StorageMountTargets
type StorageMountTargetList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []StorageMountTarget `json:"items"`
}

// Repository type metadata.
var (
	StorageMountTarget_Kind             = "StorageMountTarget"
	StorageMountTarget_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: StorageMountTarget_Kind}.String()
	StorageMountTarget_KindAPIVersion   = StorageMountTarget_Kind + "." + CRDGroupVersion.String()
	StorageMountTarget_GroupVersionKind = CRDGroupVersion.WithKind(StorageMountTarget_Kind)
)

func init() {
	SchemeBuilder.Register(&StorageMountTarget{}, &StorageMountTargetList{})
}
